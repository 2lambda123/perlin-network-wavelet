<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Build A Decentralized Chat Application with Javascript &amp; Rust (WebAssembly) · Wavelet</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Creating a **Dapp** (decentralized app) takes a lot of research and implementation effort."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Build A Decentralized Chat Application with Javascript &amp; Rust (WebAssembly) · Wavelet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://wavelet.perlin.net/"/><meta property="og:description" content="Creating a **Dapp** (decentralized app) takes a lot of research and implementation effort."/><meta property="og:image" content="https://wavelet.perlin.net/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://wavelet.perlin.net/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-142724552-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="Wavelet"/><h2 class="headerTitleWithLogo">Wavelet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/setup" target="_self">Docs</a></li><li class=""><a href="/help" target="_self">Help</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Tutorials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/setup">Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/transactions">Transactions</a></li><li class="navListItem"><a class="navItem" href="/docs/smart-contracts">Smart Contracts</a></li><li class="navListItem"><a class="navItem" href="/docs/governance">Governance</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Technical Documentation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tech/graph">Graph</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorials</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/docs/examples/decentralized-chat-app">Build A Decentralized Chat Application with Javascript &amp; Rust (WebAssembly)</a></li><li class="navListItem"><a class="navItem" href="/docs/examples/decentralized-todo-app">Build A Decentralized Todo App using VueJS &amp; Rust (WebAssembly)</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/perlin-network/wavelet/edit/master/site/docs/examples/decentralized-chat-app.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Build A Decentralized Chat Application with Javascript &amp; Rust (WebAssembly)</h1></header><article><div><span><p>Creating a <strong>Dapp</strong> (decentralized app) takes a lot of research and implementation effort.</p>
<p>Countless hours need to be spent worrying about malicious users, secure p2p networking, security, and even governance when it comes towards building a Dapp.</p>
<p>With Wavelet, creating secure, resilient Dapps is surprisingly easy.
By easy, we mean Firebase level of easy. About a hundred lines of straightforward code level of easy. Don't believe us?</p>
<p>Let's build a decentralized chat.</p>
<h2><a class="anchor" aria-hidden="true" id="what-were-going-to-be-building"></a><a href="#what-were-going-to-be-building" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What we're going to be building</h2>
<p>Like any great tutorial, it would be nice to see a live demo of what exactly you’re going to be building ahead of time.</p>
<p>Head on over to <a href="https://perlin-network.github.io/decentralized-chat">https://perlin-network.github.io/decentralized-chat</a>, and you should see this.</p>
<p><img src="https://miro.medium.com/max/700/1*T6aiBkWYGzZfJf0He2jGfQ.png" alt="alt text" title="Decentralized chat application built on Wavelet"></p>
<p>Enter your private key to your Wavelet wallet into the [secret] textbox, and make sure you have a minimum of 250,000 PERLs.</p>
<p>Press <strong>Connect</strong>, then <strong>Load Contract</strong>, and you should see messages made by other people.</p>
<p>Feel free to then fill in the message textbox with whatever message you want to send. Then simply press <strong>Send Message</strong>, pay some PERLs, and that’s pretty much it.</p>
<p>If you don’t have a private key, a Wavelet wallet, or 250,000 PERLs, keep reading and we will teach you what is a private key, how you can register your own decentralized Wavelet wallet, and how you can populate it with 250,000 PERLs.</p>
<h2><a class="anchor" aria-hidden="true" id="the-backend"></a><a href="#the-backend" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Backend</h2>
<p>To start off, we need to have a place to store our chat messages. In a normal app you’d just host up a MySQL/Postgres/MongoDB database and make a NodeJS server to collect chat messages and stuff them in your database.</p>
<p>The pros? It works. The cons? With just a couple of dollars, someone could DDoS your database server down and keep your chat service down for ages.</p>
<p>Dapps use a blockchain to store data. That data gets spread throughout potentially hundreds or thousands of nodes in a mesh network, so that even if a hacker DDoS’ the majority of your blockchains network, your app would still remain secure and available.</p>
<p>The backend API that queries/stores/modifies data to your blockchain is what we call a <strong>smart contract</strong>.</p>
<p>So, the equivalent of a NodeJS HTTP API server and a MySQL database in this tutorial would be a Rust smart contract and Wavelet (our blockchain).</p>
<p>Let’s get started building a smart contract for our chat Dapp. If you haven’t already, you need to install Rust, alongside a WebAssembly compiler backend for Rust which may be installed by executing the following command:</p>
<pre><code class="hljs css language-shell">❯ rustup target add wasm32-unknown-unknown
</code></pre>
<p>Right after, proceed to create your first Rust project by executing the following command, and take a bit of time searching up on how to install 3rd-party dependencies/libraries into your Rust project.</p>
<pre><code class="hljs css language-shell">❯ cargo new --lib chat; cd chat
</code></pre>
<p>The dependencies for building Wavelet smart contracts are available in Rust’s package repository crates.io <a href="https://crates.io/crates/smart-contract">here</a> and <a href="https://crates.io/crates/smart-contract-macros">here</a>.</p>
<p>You should have your project configuration file Cargo.toml look something like this:</p>
<pre><code class="hljs css language-toml"><span class="hljs-section">[package]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"chat"</span>
<span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span>
<span class="hljs-attr">authors</span> = [<span class="hljs-string">"Kenta Iwasaki &lt;kenta@perlin.net&gt;"</span>]
<span class="hljs-attr">edition</span> = <span class="hljs-string">"2018"</span>
<span class="hljs-section">
[profile.release]</span>
<span class="hljs-attr">lto</span> = <span class="hljs-literal">true</span>
<span class="hljs-section">
[lib]</span>
<span class="hljs-attr">crate-type</span> = [<span class="hljs-string">"cdylib"</span>]
<span class="hljs-section">
[dependencies]</span>
<span class="hljs-attr">smart-contract</span> = <span class="hljs-string">"0.2.0"</span>
<span class="hljs-attr">smart-contract-macros</span> = <span class="hljs-string">"0.2.0"</span>
</code></pre>
<p>Now that we are all setup, let me just give it to you straight: here’s what the source code of our decentralized chat smart contract looks like.</p>
<pre><code class="hljs css language-rust"><span class="hljs-keyword">use</span> smart_contract_macros::smart_contract;

<span class="hljs-keyword">use</span> smart_contract::log;
<span class="hljs-keyword">use</span> smart_contract::payload::Parameters;
<span class="hljs-keyword">use</span> std::collections::VecDeque;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Entry</span></span> {
    sender: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">32</span>],
    message: <span class="hljs-built_in">String</span>,
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chat</span></span> {
    logs: VecDeque&lt;Entry&gt;,
}

<span class="hljs-keyword">const</span> MAX_LOG_CAPACITY: <span class="hljs-built_in">usize</span> = <span class="hljs-number">50</span>;
<span class="hljs-keyword">const</span> MAX_MESSAGE_SIZE: <span class="hljs-built_in">usize</span> = <span class="hljs-number">240</span>;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">prune_old_messages</span></span>(chat: &amp;<span class="hljs-keyword">mut</span> Chat) {
    <span class="hljs-keyword">if</span> chat.logs.len() &gt; MAX_LOG_CAPACITY {
        chat.logs.pop_front();
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_hex_string</span></span>(bytes: [<span class="hljs-built_in">u8</span>; <span class="hljs-number">32</span>]) -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">let</span> strs: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt; = bytes.iter().map(|b| <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{:02x}"</span>, b)).collect();
    strs.join(<span class="hljs-string">""</span>)
}

<span class="hljs-meta">#[smart_contract]</span>
<span class="hljs-keyword">impl</span> Chat {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">init</span></span>(_params: &amp;<span class="hljs-keyword">mut</span> Parameters) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            logs: VecDeque::new(),
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send_message</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, params: &amp;<span class="hljs-keyword">mut</span> Parameters) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">String</span>&gt; {
        <span class="hljs-keyword">let</span> entry = Entry {
            sender: params.sender,
            message: params.read(),
        };

        <span class="hljs-comment">// Ensure that messages are not empty.</span>
        <span class="hljs-keyword">if</span> entry.message.len() == <span class="hljs-number">0</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(<span class="hljs-string">"Message must not be empty."</span>.into());
        }

        <span class="hljs-comment">// Ensure that message are at most 240 characters.</span>
        <span class="hljs-keyword">if</span> entry.message.len() &gt; MAX_MESSAGE_SIZE {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(<span class="hljs-built_in">format!</span>(
                <span class="hljs-string">"Message must not be more than {} characters."</span>,
                MAX_MESSAGE_SIZE
            ));
        }

        <span class="hljs-comment">// Push chat message into logs.</span>
        <span class="hljs-keyword">self</span>.logs.push_back(entry);

        <span class="hljs-comment">// Prune old messages if necessary.</span>
        prune_old_messages(<span class="hljs-keyword">self</span>);

        <span class="hljs-literal">Ok</span>(())
    }

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_messages</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, _params: &amp;<span class="hljs-keyword">mut</span> Parameters) -&gt; <span class="hljs-built_in">Result</span>&lt;(), <span class="hljs-built_in">String</span>&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> messages = <span class="hljs-built_in">Vec</span>::new();

        <span class="hljs-keyword">for</span> entry <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">self</span>.logs {
            messages.insert(
                <span class="hljs-number">0</span>,
                <span class="hljs-built_in">format!</span>(<span class="hljs-string">"&lt;{}&gt; {}"</span>, to_hex_string(entry.sender), entry.message),
            );
        }

        log(&amp;messages.join(<span class="hljs-string">"\n"</span>));

        <span class="hljs-literal">Ok</span>(())
    }
}
</code></pre>
<p>73 lines of code. That’s pretty much it (could be made smaller tbh). To explain a little bit what’s going on here:</p>
<p>The smart contract exposes two functions that may be called by our frontend: <strong>get_messages()</strong>, and <strong>send_message(msg: String)</strong>.</p>
<p>The <strong>String</strong> param for <strong>send_message(…)</strong> is read using the <strong>param.read()</strong> function when declaring the <strong>entry</strong> variable. For more details on how inputs are specified into smart contracts, click <a href="https://wavelet.perlin.net/docs/smart-contracts#parsing-input-parameters">here</a>.</p>
<p>Chat logs are stored in a <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html">VecDeque</a> (a double-ended queue where you can push items to the front of the queue, or to the end of the queue), which is initialized in <strong>init()</strong>.</p>
<p>Each chat log contains a sender ID and a message. The sender ID is a <a href="https://www.reddit.com/r/explainlikeimfive/comments/1jvduu/eli5_how_does_publicprivate_key_encryption_work/cbj44o6?utm_source=share&amp;utm_medium=web2x">cryptographic public key</a> of the person who sent the chat message.</p>
<p>You call <strong>send_message(…)</strong> to place a chat log into the logs queue. Empty chat messages are not allowed, and chat messages may at most be 240 characters.</p>
<p>The logs queue has a capacity of <em>at most 50 chat log entries</em>. Should the queue be full when a new chat log is to be inserted into the queue, the queue removes the oldest message using <strong>logs.pop_front()</strong>. This logic is handled in the <strong>prune_old_messages()</strong> function.</p>
<p>You may call <strong>get_messages()</strong> to get a human-friendly readable version of a chatlog. Sender ID’s get printed out as a hex string, and are concatenated with the senders message contents.</p>
<p>Then a <strong>log!()</strong> macro is used to have the smart contract provide to your frontend all available chat messages from <strong>get_messages()</strong>.</p>
<p>Let’s now build our smart contract using Rust’s Cargo tool:</p>
<pre><code class="hljs css language-shell">❯ cargo build --release --target wasm32-unknown-unknown
</code></pre>
<p>… and if everything goes well, in the <code>target/wasm32-unknown-unknown/release</code> folder, you will see a <code>chat.wasm</code> file.</p>
<p>That is your smart contract, ready to be deployed on Wavelet’s blockchain.</p>
<h2><a class="anchor" aria-hidden="true" id="deploying-the-backend"></a><a href="#deploying-the-backend" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deploying the Backend</h2>
<p>We need access to a Wavelet blockchain network to deploy our chat smart contract to.</p>
<p>Fear not, we hosted one up for you to test your smart contracts out with. Head on over to <a href="https://lens.perlin.net/">https://lens.perlin.net/</a>, and you’ll be faced with this login screen.</p>
<p><img src="https://miro.medium.com/max/700/1*UOw25SiactZpWhr09GYHOw.png" alt="alt text" title="Lens login screen"></p>
<p>In case you have no knowledge of what a private key is, think of it as your password. Associated to your private key is a public key, which you can think of as your username.</p>
<p>In a blockchain, there exists the concept of accounts. You register an account by generating a new private key which is uniquely associated to a public key (which we alternatively also call a wallet address).</p>
<p>So long as you don’t give away your private key, it’s going to be very hard for a hacker to steal your account. So keep your private key safe. It is what gives you access to what you can consider your public identity/username.</p>
<p>Proceed to <strong>Login</strong>, and you’ll be logged into your Wavelet account. Take note of the <strong>Wallet Address</strong> on the top left, being your public key.</p>
<p>For a bit of background:</p>
<p>Each account holds PERLs, or what some of you might know as a cryptocurrency/virtual currency.</p>
<p>So you can think of your account as a wallet holding PERLs (hence why your public key is what we call a wallet address).</p>
<p>The reason we have this currency is because there is no free lunch: the nodes supporting the Wavelet network (in this case, the one we hosted) are willing to host/keep your smart contract alive in exchange for some PERLs.</p>
<p>The way this works is that every time anyone call send_message(…) in your contract, they need to pay some PERLs to the Wavelet network.</p>
<p>Thankfully, we provided an easy way for you or your friends to get some testing PERLs on the network we’ve hosted up so that you can test your chat app.</p>
<p>To get some PERLs, we have setup a Discord server which you can join here. In the server in the <em>#wavelet-faucet channel</em>, type:</p>
<p><code>$claim [your public key/wallet address here]</code></p>
<p>A bot would then send 300,000 PERLs to your provided wallet address. Type the message a couple more times, until you have about 500,000 PERLs, and you should be good to go.</p>
<p>Head to the Developer page on the screen, press 75% button in the Gas Limit box, and upload your chat.wasm file there.</p>
<p><img src="https://miro.medium.com/max/700/1*PPEU99LQq7NtwF9aUQUd3Q.png" alt="alt text" title="Lens upload smart contract screen"></p>
<p>Wait a few seconds and you should see your smart contract ID. Make sure to jot it down/keep it for later, because we will need it to interact with our smart contract in our frontend.</p>
<p><img src="https://miro.medium.com/max/656/1*0ex6_3YnswyxZCbkp9S5Iw.png" alt="alt text" title="Lens smart contract uploaded successfully"></p>
<p><strong>And so with the push of a button, our smart contract is now live</strong>. Let’s now work on a front-end to spruce up our decentralized chat app.</p>
<h2><a class="anchor" aria-hidden="true" id="the-frontend"></a><a href="#the-frontend" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Frontend</h2>
<p>I won’t recommend any particular frameworks like React or Vue or Svelte or teach you how to style your app; it’s entirely up to you. In this section, I’ll go over the core knowledge you need to hook up your website design to Wavelet.</p>
<p>To start off, each Wavelet node in the network hosts a HTTP API which we may connect to for interacting with/querying info from the ledger.</p>
<p>The API endpoint in particular for the network we hosted up for you all, which you used to register your account and deploy your smart contract in, is the following link: <a href="https://testnet.perlin.net">https://testnet.perlin.net</a></p>
<p>On npm it’s <code>wavelet-client</code>, with the source code for it being <em>just</em> a single file located on Github here: <a href="https://github.com/perlin-network/wavelet-client-js">https://github.com/perlin-network/wavelet-client-js</a></p>
<p>Now, assuming you have <em>async/await</em> support set up, we can setup <code>wavelet-client</code> as follows:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> {Wavelet} <span class="hljs-keyword">from</span> <span class="hljs-string">"wavelet-client"</span>;

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> Wavelet(<span class="hljs-string">'https://testnet.perlin.net'</span>);
<span class="hljs-keyword">const</span> wallet = Wavelet.loadWalletFromPrivateKey(<span class="hljs-string">"YOUR_PRIVATE_KEY_HERE"</span>);

<span class="hljs-keyword">const</span> contract = <span class="hljs-keyword">new</span> Contract(client, <span class="hljs-string">"YOUR_CONTRACT_ADDRESS_HERE"</span>);
<span class="hljs-keyword">await</span> contract.init();
</code></pre>
<p>Simply, what the above code lets us do is:</p>
<ol>
<li>connect to the Wavelet network,</li>
<li>load our wallet by giving our private key so that we may pay for the fees to use our smart contract, and</li>
<li>construct a <code>Contract</code> instance which provides methods to help us with interacting with our smart contract.</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="calling-get_messages"></a><a href="#calling-get_messages" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Calling get_messages()</h2>
<p>Before continuing any further, one thing to note is that out of the two smart contract methods we defined:</p>
<ol>
<li>only one of them modifies the blockchain to push a new chat log, while</li>
<li>the other only simply queries the blockchain to retrieve all chat logs made thus far.</li>
</ol>
<p>It is good to know that the only smart contract methods which you have to pay nodes PERLs for to execute are ones that modify the blockchain.</p>
<p>So, as an example, the <strong>get_messages()</strong> function can be called without incurring any cost of PERLs to your account. You can call it like so:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> JSBI <span class="hljs-keyword">from</span> <span class="hljs-string">"jsbi"</span>; <span class="hljs-comment">// Make sure to add this as a dependency!</span>

<span class="hljs-built_in">console</span>.log(contract.test(wallet, <span class="hljs-string">'get_messages'</span>, JSBI.BigInt(<span class="hljs-number">0</span>));
</code></pre>
<p>From the code above, you might immediately be wondering: what is this additional <strong>JSBI.BigInt(0)</strong> parameter provided?</p>
<p>When calling a smart contract, apart from passing in input parameters, you may <em>additionally</em> simultaneously send the contract some of your PERLs.</p>
<p>A reason why you would want this functionality is because, for example, you might make it that certain smart contract methods only execute should 500 PERLs be sent to the contract beforehand.</p>
<p>In this case we don’t want to send our smart contract any PERLs (we’re just making a chat app 😅) upon <strong>invoking get_messages()</strong>; so we simply set the amount of PERLs to send to the contract to be zero.</p>
<p>Now, after executing the code above, you should see the following in your browsers console: <code>{&quot;result&quot;: null, &quot;logs&quot;: []}</code></p>
<p>To explain the console results, what the <strong>log!(…)</strong> macro does, which we used in building our smart contract, is place logs as strings in the “logs” array.</p>
<p>On the other hand, the “result” object is set to be the returned result/error from your smart contract function.</p>
<p>Hence, since we didn’t send any chat messages yet, the “logs” array is empty, and the “result” object is null.</p>
<p>Only after we call <strong>send_message</strong> a couple of times and re-call <strong>get_messages</strong> will we then see our messages in the “logs” array.</p>
<p>Digging a little further, should you be interested in knowing how <strong>contract.test</strong> works, what it does behind the scenes is:</p>
<ol>
<li>download your smart contracts latest memory from the node you are connected to,</li>
<li>load the smart contracts code and memory into your browsers virtual machine, and</li>
<li>locally executes the get_messages() function and returns all printed logs and results.</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="calling-send_messagemsg-string"></a><a href="#calling-send_messagemsg-string" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Calling send_message(msg:String)</h2>
<p>Now, let’s talk about calling the <strong>send_message(msg: String)</strong> function. As you might guess, calling this function <em>modifies</em> the blockchain by putting your desired message on the blockchain, and thus costs PERLs.</p>
<p>The way it may be called with the Wavelet JS client is actually pretty similar to the code for <strong>get_messages()</strong>:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">await</span> contract.call(
  wallet, 
  <span class="hljs-string">'send_message'</span>, 
  JSBI.BigInt(<span class="hljs-number">0</span>), <span class="hljs-comment">// amount to send</span>
  JSBI.BigInt(<span class="hljs-number">250000</span>), <span class="hljs-comment">// gas limit</span>
  JSBI.BigInt(<span class="hljs-number">0</span>), <span class="hljs-comment">// gas deposit (not explained)</span>
  {<span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"Your chat message here!"</span>},
);
</code></pre>
<p>Everything is the same, except you pass in your wallet as the first parameter, and you specify your message as as an input parameter encoded as an object like so:</p>
<p><code>{type: &quot;string&quot;, value: &quot;Your chat message here!&quot;}</code></p>
<p>Just to put it out there, should you ever make a smart contract function outside of the scope of this tutorial that requests multiple parameters, you may pass multiple input parameters as a variadic list to the <strong>contract.call</strong> function like so:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">await</span> contract.call(...[ 
  {<span class="hljs-attr">type</span>: <span class="hljs-string">"uint32"</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">32</span>}, <span class="hljs-comment">// Pass in an unsigned little-endian 32-bit integer.</span>
  {<span class="hljs-attr">type</span>: <span class="hljs-string">"int64"</span>, <span class="hljs-attr">value</span>: JSBI.BigInt(<span class="hljs-number">-100000000</span>)}, <span class="hljs-comment">// Pass in a signed little-endian 64-bit integer.</span>
  {<span class="hljs-attr">type</span>: <span class="hljs-string">"string"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"Another string"</span>}, <span class="hljs-comment">// Pass in a string.</span>
  {<span class="hljs-attr">type</span>: <span class="hljs-string">"raw"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"hexadecimal_string_here_to_be_decoded_into_raw_bytes"</span>}] <span class="hljs-comment">// Pass in raw bytes hex-encoded.</span>
)
</code></pre>
<p>Now, much like the odd <strong>JSBI.BigInt(0)</strong> passed in, you might be wondering what the second <strong>JSBI.BigInt(250000</strong>) passed in is for.</p>
<p>In order to make sure you do not spend too much PERLs accidentally executing your function, you can set a limit to how much PERLs may attempt to be spent on executing your smart contract function.</p>
<p>In this case, what the code above denotes is that your call to <strong>send_message()</strong> would at most expend 250,000 PERLs.</p>
<p>The explicit PERL fee you pay for executing a modifying smart contract call is computed based on how many instructions your smart contract has to execute to fully execute the smart contract method you desire.</p>
<p>More details on the fee structure when it comes to executing smart contract methods may be found <a href="/docs/smart-contracts#gas-limits-and-fees">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="listening-for-changes-to-the-blockchain"></a><a href="#listening-for-changes-to-the-blockchain" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Listening for changes to the blockchain</h2>
<p>The one final bit perhaps that would be great to have is to automatically refresh the chat logs when new chat logs are appended to the blockchain.</p>
<p>Updates are batched and then published together inside Wavelet into what is called a “consensus round”. So everytime the blockchain gets modified, after a second or two, a “consensus round” ends/passes.</p>
<p>We can use the Wavelet JS client to listen for when a round ends, download the latest updated smart contract memory, and re-execute get_messages() to collect the latest chat logs which we may update our frontend with like so:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">await</span> client.pollConsensus({
    <span class="hljs-attr">onRoundEnded</span>: <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span> {
        (<span class="hljs-keyword">async</span> () =&gt; {
            <span class="hljs-keyword">await</span> contract.fetchAndPopulateMemoryPages();
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Chat logs updated:"</span>, contract.test(<span class="hljs-string">'get_messages'</span>, BigInt(<span class="hljs-number">0</span>)));
        })();
    }
});
</code></pre>
<p>In the code above, what is happening is that the <strong>fetchAndPopulateMemoryPages()</strong> function is called every single time a consensus round ends. The function downloads your smart contracts latest memory data.</p>
<p>What then follows is a single call to <strong>get_messages()</strong>, providing you with the latest logs and results being printed straight to your browsers console.</p>
<h2><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>So with all of these different components, you now have a full-fledged decentralized chat app with a splendid backend and (hopefully splendid) frontend.</p>
<p>Hopefully, after a bit of cleanup, it looks a little something like this:</p>
<p><img src="https://miro.medium.com/max/700/1*1nO7M9UzA2sw8U5vqlooAw.png" alt="alt text" title="Decentralized chat application with a nice front-end"></p>
<p>If it doesn’t, either way, congratulations, you've made your very first scalable, secure, Wavelet Dapp!</p>
<p>If you need any help, are interested to know more, or are stuck at any bits throughout the tutorial, feel free to reach us over on our Discord <a href="https://discord.gg/dMYfDPM">here</a>.</p>
<p>Source code for the entire tutorial can be found <a href="https://github.com/perlin-network/decentralized-chat">here</a></p>
<p>The original tutorial is written by Kenta Iwasaki and can be found <a href="https://medium.com/perlin-network/build-a-decentralized-chat-using-javascript-rust-webassembly-c775f8484b52">here</a>.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2019-10-1</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/tech/graph"><span class="arrow-prev">← </span><span>Graph</span></a><a class="docs-next button" href="/docs/examples/decentralized-todo-app"><span class="function-name-prevnext">Build A Decentralized Todo App using VueJS &amp; Rust (WebAssembly)</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-were-going-to-be-building">What we're going to be building</a></li><li><a href="#the-backend">The Backend</a></li><li><a href="#deploying-the-backend">Deploying the Backend</a></li><li><a href="#the-frontend">The Frontend</a></li><li><a href="#calling-get_messages">Calling get_messages()</a></li><li><a href="#calling-send_messagemsg-string">Calling send_message(msg:String)</a></li><li><a href="#listening-for-changes-to-the-blockchain">Listening for changes to the blockchain</a></li><li><a href="#conclusion">Conclusion</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/favicon.ico" alt="Wavelet" width="56" height="44"/></a><div><h5>Docs</h5><a href="/docs/en/setup">Getting Started</a></div><div><h5>Community</h5><a href="https://discord.gg/dMYfDPM" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://twitter.com/PerlinNetwork" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="https://github.com/perlin-network/wavelet">GitHub</a><a class="github-button" href="https://github.com/perlin-network/wavelet" data-icon="octicon-star" data-count-href="/perlin-network/wavelet/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://perlin.net" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/perlin-logo.svg" alt="Perlin Open Source" width="170" height="60"/></a><section class="copyright">Copyright © 2019 Perlin</section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>